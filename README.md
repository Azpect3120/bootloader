# Booting from scratch
Loads memory into the address *0x7C00*

Looks for the signature of the boot sector *0x55AA* at the end of the sector, the *last two* bytes.

Using the *times* direction to fill the rest of the sector with zeros.

```nasm
; ($-$$) is the current address minus the start address
; db is the data byte direction
times 510-($-$$) db 0
```
We have to set the bits to 16 at the start because all systems START at 16 bits to ensure compatibility with older systems

# Disks

CHS: Cylinder, Head, Sector

LBA: Logical Block Address

## Converting CHS to LBA

LBA = (C * TH * TS) + (H * TS) + (S - 1)

C = Sector cylinder number

TH = Total headers on disk

TS = Total sections on disk

H = Sector head number

S = Sector's number

## Converting LBA to CHS
t = LBA / sectors per track

S = (LBA % sectors per track) + 1

H = t % number of heads

C = t / number of headers

## 16 Bit C Compiler
```
https://github.com/open-watcom/open-watcom-v2/releases
```

## What is linker.lnk
```
FORMAT RAW BIN:
    This specifies the format of the output file generated by the linker. In this case, it indicates that the output should be in raw binary format, meaning there won't be any headers or metadata included in the output file.

OPTION QUIET, NODEFAULTLIBS, START=entry, VERBOSE, OFFSET=0, STACK=0x200:
    These are various linker options and directives:
        QUIET: Suppresses informational messages during the linking process, making it quieter.
        NODEFAULTLIBS: Instructs the linker not to include any default libraries during linking. This means that all libraries used in the program must be explicitly specified.
        START=entry: Specifies the entry point of the program. The entry point is where the program execution starts after it is loaded into memory.
        VERBOSE: Indicates that the linker should output more detailed information during the linking process.
        OFFSET=0: Specifies the offset at which the program should be loaded into memory. In this case, it's set to load at the beginning of the memory.
        STACK=0x200: Sets the size of the stack for the program to 0x200 (512 in decimal) bytes. The stack is used for storing local variables and function call information during program execution.

ORDER:
    This section specifies the order in which different segments of the program should be placed in memory. It organizes the code and data segments into different classes, which are then placed in memory according to this order.

CLNAME:
    This directive specifies the name of a class of segments.
    In this case, there are two class names specified: CODE and DATA.

SEGMENT:
    This directive specifies a segment to be included in the class.
    Within each class, one or more segments are listed. Each segment typically corresponds to a section of the program, such as code or data.
```

Overall, the linker.lnk file provides instructions to the linker on how to organize and link different sections of code and data to produce the final executable file. It specifies options, entry points, memory layout, and segment ordering to ensure that the program behaves as expected when executed.

## Returning values in ASM implementations

```c
double(entier n) { return n + n; }
```

Since it appears that you are throughly confused by this, let me just show you how to do it:

```asm
double: push ebp       ; establish...
    mov ebp, esp       ; ...stack frame

    mov eax, [ebp + 8] ; load argument from stack into eax
    add eax, eax       ; add it to itself

    leave              ; tear down the stack frame
    ret                ; return to the caller
```

Note that I chose eax instead of ebx for the register. This is for two reasons:

- `eax` is a caller-saved register (meaning that the caller must take care to preserve its 
    value if desired) whereas `ebx` is a callee-saved register (meaning that the callee, i.e.
    double must preserve its value). If we wanted to use `ebx`, we had to save and restore 
    its old value. If we use a caller-saved register like eax instead, we can avoid this effort.

- `eax` is the register where by convention the return value is found. The caller will take the 
    value of `eax` as the return value.

- In almost all calling conventions for x86, the return value is whatever value is found in `eax`
    on return. Thus, by placing the result of the addition in `eax`, we don't have to do any extra 
    work to set up the return value.

